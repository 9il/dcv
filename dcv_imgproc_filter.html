<h1>dcv.imgproc.filter</h1>
           Module introduces image filtering functions and utilities.
<br><br>
<b>Authors:</b><br>
Relja Ljubobratovic

<br><br>
<b>License:</b><br>
<a target="_blank" href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License - Version 1.0</a>.
<br><br>

<dl>Module contains:
    <dd>            <big>Filter kernel generators: </big>
            <a href="#gaussian">gaussian</a>
            <a href="#laplacian">laplacian</a>
            <a href="#laplacianOfGaussian">laplacianOfGaussian</a>
            <a href="#sobel">sobel</a>
            <a href="#scharr">scharr</a>
            <a href="#prewitt">prewitt</a>
    </dd>
    <dd>            <big>Image processing functions: </big>
            <a href="#filterNonMaximum">filterNonMaximum</a>
            <a href="#calcPartialDerivatives">calcPartialDerivatives</a>
            <a href="#calcGradients">calcGradients</a>
            <a href="#nonMaximaSupression">nonMaximaSupression</a>
            <a href="#canny">canny</a>
            <a href="#bilateralFilter">bilateralFilter</a>
            <a href="#medianFilter">medianFilter</a>
            <a href="#calcHistogram">calcHistogram</a>
            <a href="#histEqual">histEqual</a>
    </dd>
</dl><br><br>

<dl><dt><big><a name="gaussian"></a>pure Slice!(2, V*) <u id="gaussian">gaussian</u>(V = real)(real <i>sigma</i>, size_t <i>width</i>, size_t <i>height</i>);
</big></dt>
<dd>Instantiate 2D <u id="gaussian">gaussian</u> kernel.<br><br>

</dd>
<dt><big><a name="laplacian"></a>pure nothrow Slice!(2, T*) <u id="laplacian">laplacian</u>(T = real)(real <i>a</i> = 0.00000) if (isNumeric!T);
</big></dt>
<dd>Create negative <u id="laplacian">laplacian</u> 3x3 kernel matrix.
<br><br>
Creates <u id="laplacian">laplacian</u> kernel matrix using
<br><br>

<pre class="d_code">I - image
Laplacian(I) =
             [<i>a</i>/4,    (1-<i>a</i>)/4,   <i>a</i>/4]
   4/(<i>a</i>+1) * |(1-<i>a</i>)/4   -1   (1-<i>a</i>)/4|
             [<i>a</i>/4,    (1-<i>a</i>)/4,   <i>a</i>/4]
</pre><br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.algorithm.comparison : equal;

<font color=blue>auto</font> l4 = <u id="laplacian">laplacian</u>(); <font color=green>// laplacian!real(0);
</font><font color=blue>assert</font>(equal(l4.byElement, [0, 1, 0, 1, -4, 1, 0, 1, 0]));
</pre>
<br><br>
</dd>
<dt><big><a name="laplacianOfGaussian"></a>Slice!(2, T*) <u id="laplacianOfGaussian">laplacianOfGaussian</u>(T = real)(real <i>sigma</i>, size_t <i>width</i>, size_t <i>height</i>);
</big></dt>
<dd>Create laplacian of gaussian <a target="_blank" href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/log.htm">(LoG)</a> filter kernel.
<br><br>
<b>Params:</b><br>
<table><tr><td>real <i>sigma</i></td>
<td>gaussian <i>sigma</i> variance value</td></tr>
<tr><td>size_t <i>width</i></td>
<td><i>width</i> of the kernel matrix</td></tr>
<tr><td>size_t <i>height</i></td>
<td><i>height</i> of the kernel matrix</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.algorithm.comparison : equal;
<font color=blue>import</font> std.math : approxEqual;

<font color=blue>auto</font> log = <u id="laplacianOfGaussian">laplacianOfGaussian</u>!<font color=blue>float</font>(0.84f, 3, 3);
<font color=blue>auto</font> expected = [0.147722, -0.00865228, 0.147722, -0.00865228, -0.556277, -0.00865228,
    0.147722, -0.00865228, 0.147722].sliced(3, 3);
<font color=blue>assert</font>(log.byElement.array.equal!approxEqual(expected.byElement.array));
</pre>
<br><br>
</dd>
<dt><big><a name="EdgeKernel"></a>enum <u id="EdgeKernel">EdgeKernel</u>: int;
</big></dt>
<dd>Convolution kernel type for edge detection.<br><br>

</dd>
<dt><big><a name="sobel"></a>pure nothrow @trusted Slice!(2, T*) <u id="sobel">sobel</u>(T = real)(GradientDirection <i>direction</i>);
</big></dt>
<dd>Create a Sobel edge kernel.<br><br>

</dd>
<dt><big><a name="scharr"></a>pure nothrow @trusted Slice!(2, T*) <u id="scharr">scharr</u>(T = real)(GradientDirection <i>direction</i>);
</big></dt>
<dd>Create a Scharr edge kernel.<br><br>

</dd>
<dt><big><a name="prewitt"></a>pure nothrow @trusted Slice!(2, T*) <u id="prewitt">prewitt</u>(T = real)(GradientDirection <i>direction</i>);
</big></dt>
<dd>Create a Prewitt edge kernel.<br><br>

</dd>
<dt><big><a name="edgeKernel"></a>pure nothrow @trusted Slice!(2, T*) <u id="edgeKernel">edgeKernel</u>(T)(EdgeKernel <i>kernelType</i>, GradientDirection <i>direction</i>);
</big></dt>
<dd>Create a kernel of given type.<br><br>

</dd>
<dt><big><a name="filterNonMaximum"></a>Slice!(2, T*) <u id="filterNonMaximum">filterNonMaximum</u>(T)(Slice!(2, T*) <i>slice</i>, size_t <i>filterSize</i> = 10);
</big></dt>
<dd>Perform non-maxima filtering of the image.
<br><br>
<b>note:</b><br>
proxy function, not a proper API!<br><br>

</dd>
<dt><big><a name="calcPartialDerivatives"></a>void <u id="calcPartialDerivatives">calcPartialDerivatives</u>(T, V = T)(Slice!(2, T*) <i>slice</i>, ref Slice!(2, V*) <i>fx</i>, ref Slice!(2, V*) <i>fy</i>) if (isFloatingPoint!V);
</big></dt>
<dd>Calculate partial derivatives of an <i>slice</i>.
<br><br>
Partial derivatives are calculated by convolving an <i>slice</i> with
[-1, 1] kernel, horizontally and vertically.<br><br>

</dd>
<dt><big><a name="calcGradients"></a>void <u id="calcGradients">calcGradients</u>(T, V = T)(Slice!(2, T*) <i>slice</i>, ref Slice!(2, V*) <i>mag</i>, ref Slice!(2, V*) <i>orient</i>, EdgeKernel <i>edgeKernelType</i> = EdgeKernel.SIMPLE) if (isFloatingPoint!V);
</big></dt>
<dd>Calculate gradient magnitude and orientation of an image <i>slice</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(2, T*) <i>slice</i></td>
<td>Input <i>slice</i> of an image.</td></tr>
<tr><td>Slice!(2, V*) <i>mag</i></td>
<td>Output magnitude value of gradients.</td></tr>
<tr><td>Slice!(2, V*) <i>orient</i></td>
<td>Orientation value of gradients in radians.</td></tr>
<tr><td>EdgeKernel <i>edgeKernelType</i></td>
<td>Optional convolution kernel type to calculate partial derivatives.
    Default value is EdgeKernel.SIMPLE, which calls calcPartialDerivatives function
    to calculate derivatives. Other options will perform convolution with requested
    kernel type.</td></tr>
</table><br>

</dd>
<dt><big><a name="nonMaximaSupression"></a>Slice!(2, V*) <u id="nonMaximaSupression">nonMaximaSupression</u>(T, V = T)(Slice!(2, T*) <i>mag</i>, Slice!(2, T*) <i>orient</i>, Slice!(2, V*) <i>prealloc</i> = emptySlice!(2, V));
</big></dt>
<dd>Edge detection impuls non-maxima supression.
<br><br>
Filtering used in canny edge detection algorithm - suppresses all
edge impulses (gradient values along edges normal) except the peek value.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(2, T*) <i>mag</i></td>
<td>Gradient magnitude.</td></tr>
<tr><td>Slice!(2, T*) <i>orient</i></td>
<td>Gradient orientation of the same image source as magnitude.</td></tr>
<tr><td>Slice!(2, V*) <i>prealloc</i></td>
<td>Optional pre-allocated buffer for output slice.</td></tr>
</table><br>
<b>see:</b><br>
dcv.imgproc.filter.calcGradients, dcv.imgproc.convolution<br><br>

</dd>
<dt><big><a name="canny"></a>Slice!(2, V*) <u id="canny">canny</u>(V, T)(Slice!(2, T*) <i>slice</i>, T <i>lowThresh</i>, T <i>upThresh</i>, EdgeKernel <i>edgeKernelType</i> = EdgeKernel.SOBEL, Slice!(2, V*) <i>prealloc</i> = emptySlice!(2, V));
</big></dt>
<dd>Perform <u id="canny">canny</u> filtering on an image to expose edges.
<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(2, T*) <i>slice</i></td>
<td>Input image <i>slice</i>.</td></tr>
<tr><td>T <i>lowThresh</i></td>
<td>lower threshold value after non-maxima suppression.</td></tr>
<tr><td>T <i>upThresh</i></td>
<td>upper threshold value after non-maxima suppression.</td></tr>
<tr><td>EdgeKernel <i>edgeKernelType</i></td>
<td>Type of edge kernel used to calculate image gradients.</td></tr>
<tr><td>Slice!(2, V*) <i>prealloc</i></td>
<td>Optional pre-allocated buffer.</td></tr>
</table><br>

</dd>
<dt><big><a name="canny.2"></a>Slice!(2, V*) <u id="canny">canny</u>(V, T)(Slice!(2, T*) <i>slice</i>, T <i>thresh</i>, EdgeKernel <i>edgeKernelType</i> = EdgeKernel.SOBEL, Slice!(2, V*) <i>prealloc</i> = emptySlice!(2, V));
</big></dt>
<dd>Perform <u id="canny">canny</u> filtering on an image to expose edges.
<br><br>
Convenience function to call <u id="canny">canny</u> with same lower and upper threshold values,
similar to dcv.imgproc.threshold.threshold.<br><br>

</dd>
<dt><big><a name="bilateralFilter"></a>Slice!(N, OutputType*) <u id="bilateralFilter">bilateralFilter</u>(alias bc = neumann, InputType, OutputType = InputType, size_t N)(Slice!(N, InputType*) <i>slice</i>, float <i>sigma</i>, uint <i>kernelSize</i>, Slice!(N, OutputType*) <i>prealloc</i> = emptySlice!(N, OutputType)) if (N == 2);
<br>Slice!(N, OutputType*) <u id="bilateralFilter">bilateralFilter</u>(alias bc = neumann, InputType, OutputType = InputType, size_t N)(Slice!(N, InputType*) <i>slice</i>, float <i>sigma</i>, uint <i>kernelSize</i>, Slice!(N, OutputType*) <i>prealloc</i> = emptySlice!(N, OutputType)) if (N == 3);
</big></dt>
<dd><a href="https://en.wikipedia.org/wiki/Bilateral_filter">Bilateral</a> filtering implementation.
<br><br>
Non-linear, edge-preserving and noise-reducing smoothing filtering algorithm.

<br><br>
<b>Params:</b><br>
<table><tr><td>bc</td>
<td>Boundary condition test used to index the image <i>slice</i>.</td></tr>
<tr><td>Slice!(N, InputType*) <i>slice</i></td>
<td>Slice of the input image.</td></tr>
<tr><td>float <i>sigma</i></td>
<td>Smoothing strength parameter.</td></tr>
<tr><td>uint <i>kernelSize</i></td>
<td>Size of convolution kernel. Must be odd number.</td></tr>
<tr><td>Slice!(N, OutputType*) <i>prealloc</i></td>
<td>Optional pre-allocated result image buffer. If not of same shape as input <i>slice</i>, its allocated
        anew.</td></tr>
</table><br>
<b>Returns:</b><br>
Slice of filtered image.<br><br>

</dd>
<dt><big><a name="medianFilter"></a>Slice!(N, O*) <u id="medianFilter">medianFilter</u>(alias BoundaryConditionTest = neumann, T, O = T, size_t N)(Slice!(N, T*) <i>slice</i>, ulong <i>kernelSize</i>, Slice!(N, O*) <i>prealloc</i> = emptySlice!(N, O));
</big></dt>
<dd>Median filtering algorithm.
<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(N, T*) <i>slice</i></td>
<td>Input image <i>slice</i>.</td></tr>
<tr><td>ulong <i>kernelSize</i></td>
<td>Square size of median kernel.</td></tr>
<tr><td>Slice!(N, O*) <i>prealloc</i></td>
<td>Optional pre-allocated return image buffer.</td></tr>
</table><br>
<b>Returns:</b><br>
Returns filtered image of same size as the input. If <i>prealloc</i> parameter is not an empty <i>slice</i>, and is
    of same size as input <i>slice</i>, return value is assigned to <i>prealloc</i> buffer. If not, newly allocated buffer
    is used.<br><br>

</dd>
<dt><big><a name="calcHistogram"></a>HistogramType <u id="calcHistogram">calcHistogram</u>(Range, HistogramType = int[(ElementType!Range).max + 1])(Range <i>range</i>) if (isForwardRange!Range &amp;&amp; (isDynamicArray!HistogramType || isStaticArray!HistogramType));
</big></dt>
<dd>Calculate <i>range</i> value histogram.
<br><br>
<b>Params:</b><br>
<table><tr><td>HistogramType</td>
<td>(template parameter) Histogram type. Valued types are static and dynamic arrays.
    Most commonly is 32 bit integer static array of size T.max + 1, where T is element type of input <i>range</i>.</td></tr>
<tr><td>Range <i>range</i></td>
<td>Input forward <i>range</i>, for which histogram is calculated.</td></tr>
</table><br>
<b>Returns:</b><br>
Histogram for given forward <i>range</i>.<br><br>

</dd>
<dt><big><a name="histEqual"></a>Slice!(N, T*) <u id="histEqual">histEqual</u>(T, HistogramType, size_t N)(Slice!(N, T*) <i>slice</i>, HistogramType <i>histogram</i>, Slice!(N, T*) <i>prealloc</i> = emptySlice!(N, T));
</big></dt>
<dd>Histogram Equalization.
<br><br>
Equalize <i>histogram</i> of given image <i>slice</i>. Slice can be 2D for grayscale, and 3D for color images.
If 3D <i>slice</i> is given, <i>histogram</i> is applied separatelly for each channel.

<br><br>
<b>Note:</b><br>
For more valid color <i>histogram</i> equalization results, try converting image to HSV color model
    to perform equalization for V channel, <a href="https://en.wikipedia.org/wiki/Histogram_equalization#Histogram_equalization_of_color_images">to alter the color as less as possible</a>.

<br><br>
<b>Params:</b><br>
<table><tr><td>Histogram</td>
<td>(template parameter) Histogram type, see calcHistogram function for details.
    larger integer value type, and T is value type of input image <i>slice</i>.</td></tr>
<tr><td>Slice!(N, T*) <i>slice</i></td>
<td>Input image <i>slice</i>.</td></tr>
<tr><td>HistogramType <i>histogram</i></td>
<td>Histogram values for input image <i>slice</i>.</td></tr>
<tr><td>Slice!(N, T*) <i>prealloc</i></td>
<td>Optional pre-allocated buffer where equalized image is saved.</td></tr>
</table><br>
<b>Returns:</b><br>
Copy of input image <i>slice</i> with its <i>histogram</i> values equalized.<br><br>

</dd>
</dl>

           <hr>Copyright Relja Ljubobratovic 2016.


