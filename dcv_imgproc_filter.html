<h1>dcv.imgproc.filter</h1>
           <br><br>
<dl><dt><big><a name="gaussian"></a>pure Slice!(2, V*) <u>gaussian</u>(V = real)(real <i>sigma</i>, size_t <i>width</i>, size_t <i>height</i>);
</big></dt>
<dd>Instantiate 2D <u>gaussian</u> kernel.<br><br>

</dd>
<dt><big><a name="laplacian"></a>pure nothrow Slice!(2, T*) <u>laplacian</u>(T = real)(real <i>a</i> = 0.00000) if (isNumeric!T);
</big></dt>
<dd>Create negative <u>laplacian</u> 3x3 kernel matrix.
<br><br>
Creates <u>laplacian</u> kernel matrix using
<br><br>

 I - image
 Laplacian(I) =
              [<i>a</i>/4,    (1-<i>a</i>)/4,   <i>a</i>/4]
    4/(<i>a</i>+1) * |(1-<i>a</i>)/4   -1   (1-<i>a</i>)/4|
              [<i>a</i>/4,    (1-<i>a</i>)/4,   <i>a</i>/4]<br><br>

</dd>
<dt><big><a name="laplacianOfGaussian"></a>Slice!(2, T*) <u>laplacianOfGaussian</u>(T = real)(real <i>sigma</i>, size_t <i>width</i>, size_t <i>height</i>);
</big></dt>
<dd>Create laplacian of gaussian (LoG) filter kernel.
<br><br>
<b>Params:</b><br>
<table><tr><td>real <i>sigma</i></td>
<td>gaussian <i>sigma</i> variance value</td></tr>
<tr><td>size_t <i>width</i></td>
<td><i>width</i> of the kernel matrix</td></tr>
<tr><td>size_t <i>height</i></td>
<td><i>height</i> of the kernel matrix</td></tr>
</table><br>

</dd>
<dt><big><a name="EdgeKernel"></a>enum <u>EdgeKernel</u>: int;
</big></dt>
<dd>Convolution kernel type for edge detection.<br><br>

</dd>
<dt><big><a name="sobel"></a>pure nothrow @trusted Slice!(2, T*) <u>sobel</u>(T = real)(GradientDirection <i>direction</i>);
</big></dt>
<dd>Create a Sobel edge kernel.<br><br>

</dd>
<dt><big><a name="scharr"></a>pure nothrow @trusted Slice!(2, T*) <u>scharr</u>(T = real)(GradientDirection <i>direction</i>);
</big></dt>
<dd>Create a Scharr edge kernel.<br><br>

</dd>
<dt><big><a name="prewitt"></a>pure nothrow @trusted Slice!(2, T*) <u>prewitt</u>(T = real)(GradientDirection <i>direction</i>);
</big></dt>
<dd>Create a Prewitt edge kernel.<br><br>

</dd>
<dt><big><a name="edgeKernel"></a>pure nothrow @trusted Slice!(2, T*) <u>edgeKernel</u>(T)(EdgeKernel <i>kernelType</i>, GradientDirection <i>direction</i>);
</big></dt>
<dd>Create a kernel of given type.<br><br>

</dd>
<dt><big><a name="filterNonMaximum"></a>Slice!(2, T*) <u>filterNonMaximum</u>(T)(Slice!(2, T*) <i>slice</i>, size_t <i>filterSize</i> = 10);
</big></dt>
<dd>Perform non-maxima filtering of the image.
<br><br>
<b>note:</b><br>
proxy function, not a proper API!

<br><br>
<b>TODO:</b><br>
Implement non-maxima supression for edge detection (canny), and
 make the interface of the function fit both needs.<br><br>

</dd>
<dt><big><a name="calcPartialDerivatives"></a>void <u>calcPartialDerivatives</u>(T, V = T)(Slice!(2, T*) <i>slice</i>, ref Slice!(2, V*) <i>fx</i>, ref Slice!(2, V*) <i>fy</i>) if (isFloatingPoint!V);
</big></dt>
<dd>Calculate partial derivatives of an <i>slice</i>.
<br><br>
Partial derivatives are calculated by convolving an <i>slice</i> with
 [-1, 1] kernel, horizontally and vertically.<br><br>

</dd>
<dt><big><a name="calcGradients"></a>void <u>calcGradients</u>(T, V = T)(Slice!(2, T*) <i>slice</i>, ref Slice!(2, V*) <i>mag</i>, ref Slice!(2, V*) <i>orient</i>, EdgeKernel <i>edgeKernelType</i> = EdgeKernel.SIMPLE) if (isFloatingPoint!V);
</big></dt>
<dd>Calculate gradient magnitude and orientation of an image <i>slice</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(2, T*) <i>slice</i></td>
<td>Input <i>slice</i> of an image.</td></tr>
<tr><td>Slice!(2, V*) <i>mag</i></td>
<td>Output magnitude value of gradients.</td></tr>
<tr><td>Slice!(2, V*) <i>orient</i></td>
<td>Orientation value of gradients in radians.</td></tr>
<tr><td>EdgeKernel <i>edgeKernelType</i></td>
<td>Optional convolution kernel type to calculate partial derivatives.
 Default value is EdgeKernel.SIMPLE, which calls calcPartialDerivatives function
 to calculate derivatives. Other options will perform convolution with requested
 kernel type.</td></tr>
</table><br>

</dd>
<dt><big><a name="nonMaximaSupression"></a>Slice!(2, V*) <u>nonMaximaSupression</u>(T, V = T)(Slice!(2, T*) <i>mag</i>, Slice!(2, T*) <i>orient</i>, Slice!(2, V*) <i>prealloc</i> = emptySlice!(2, V));
</big></dt>
<dd>Edge detection impuls non-maxima supression.
<br><br>
Filtering used in canny edge detection algorithm - suppresses all
 edge impulses (gradient values along edges normal) except the peek value.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(2, T*) <i>mag</i></td>
<td>Gradient magnitude.</td></tr>
<tr><td>Slice!(2, T*) <i>orient</i></td>
<td>Gradient orientation of the same image source as magnitude.</td></tr>
<tr><td>Slice!(2, V*) <i>prealloc</i></td>
<td>Optional pre-allocated buffer for output slice.</td></tr>
</table><br>
<b>see:</b><br>
dcv.imgproc.filter.calcGradients, dcv.imgproc.convolution<br><br>

</dd>
<dt><big><a name="canny"></a>Slice!(2, V*) <u>canny</u>(V, T)(Slice!(2, T*) <i>slice</i>, T <i>lowThresh</i>, T <i>upThresh</i>, EdgeKernel <i>edgeKernelType</i> = EdgeKernel.SOBEL, Slice!(2, V*) <i>prealloc</i> = emptySlice!(2, V));
</big></dt>
<dd>Perform <u>canny</u> filtering on an image to expose edges.
<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(2, T*) <i>slice</i></td>
<td>Input image <i>slice</i>.</td></tr>
<tr><td>T <i>lowThresh</i></td>
<td>lower threshold value after non-maxima suppression.</td></tr>
<tr><td>T <i>upThresh</i></td>
<td>upper threshold value after non-maxima suppression.</td></tr>
<tr><td>EdgeKernel <i>edgeKernelType</i></td>
<td>Type of edge kernel used to calculate image gradients.</td></tr>
<tr><td>Slice!(2, V*) <i>prealloc</i></td>
<td>Optional pre-allocated buffer.</td></tr>
</table><br>

</dd>
<dt><big><a name="canny.2"></a>Slice!(2, V*) <u>canny</u>(V, T)(Slice!(2, T*) <i>slice</i>, T <i>thresh</i>, EdgeKernel <i>edgeKernelType</i> = EdgeKernel.SOBEL, Slice!(2, V*) <i>prealloc</i> = emptySlice!(2, V));
</big></dt>
<dd>Perform <u>canny</u> filtering on an image to expose edges.
<br><br>
Convenience function to call <u>canny</u> with same lower and upper threshold values,
 similar to dcv.imgproc.threshold.threshold.<br><br>

</dd>
</dl>

           <hr>
