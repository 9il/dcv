<h1 id="image-filtering-example">Image filtering example</h1>
<p>This example should demonstrate how to apply basic spatial filtering methods to images, using dcv. Should also provide insight to basic setup for any image processing, such as image i/o, image convertion to Slice object etc.</p>
<h2 id="modules-used">Modules used</h2>
<ul>
<li>dcv.core.image</li>
<li>dcv.core.utils</li>
<li>dcv.io</li>
<li>dcv.imgproc</li>
</ul>
<h2 id="source-image">Source Image</h2>
<p>As source image in this example, famous image of Lena Söderberg is used. Source data is loaded with next chunk of code:</p>
<div ><pre style="margin: 0; line-height: 125%">string impath = (args.length &lt; 2) ? <span style="color: #a31515">&quot;../data/lena.png&quot;</span> : args[1];

Image img = imread(impath); <span style="color: #008000">// read an image from filesystem.</span>

<span style="color: #0000ff">if</span> (img.empty) { <span style="color: #008000">// check if image is properly read.</span>
    writeln(<span style="color: #a31515">&quot;Cannot read image at: &quot;</span> ~ impath);
    <span style="color: #0000ff">return</span> 1;
}

Slice!(3, <span style="color: #2b91af">float</span>*) imslice = img
    .asType!<span style="color: #2b91af">float</span> <span style="color: #008000">// convert Image data type from ubyte to float</span>
    .sliced!<span style="color: #2b91af">float</span>; <span style="color: #008000">// slice image data - calls img.data!float.sliced(img.height, img.width, img.channels)</span>
</pre></div>
<br>
<div class="figure">
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/data/lena.png?raw=true" alt="alt tag" />
</div>
<h2 id="filter-kernel-creation">Filter Kernel Creation</h2>
<p>In this example spatial filtering is done with image convolution by using gaussian, sobel, laplacian and LoG(laplacian of gaussian) operators. These operators can be created by using functions present in <code>dcv.imgproc.filter</code> module. Each function takes a template argument as matrix (Slice) type, which is by default <code>real</code>.</p>
<h2 id="gaussian-blurring">Gaussian Blurring</h2>
<p>Classic gaussian kernel is created using <code>dcv.imgproc.filter.gaussian</code> function. By convolving an image with created kernel, we can perform image blurring.</p>
<p>We create gaussian (2D) kernel with sigma value of 2.0, of size 5x5, and then we convolve the image with it:</p>
<div><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">auto</span> gaussianKernel = gaussian!<span style="color: #2b91af">float</span>(2, 5, 5);
<span style="color: #0000ff">auto</span> blur = imslice.conv(gaussianKernel);
</pre></div>
<p id="result">... Which gives following result:</p>
<div class="figure">
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/filter/result/outblur.png?raw=true" alt="alt tag" />
</div>
<h2 id="edge-detection">Edge Detection</h2>
<p>In this example, few well known operators are used for spatial edge extraction - sobel, laplacian and laplacian of gaussian. Operators are created with:</p>
<div ><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">auto</span> sobelXKernel = sobel!<span style="color: #2b91af">real</span>(GradientDirection.DIR_X); <span style="color: #008000">// sobel operator for horizontal (X) gradients</span>
<span style="color: #0000ff">auto</span> laplacianKernel = laplacian!<span style="color: #2b91af">double</span>; <span style="color: #008000">// laplacian kernel, similar to matlabs fspecial(&#39;laplacian&#39;, alpha)</span>
<span style="color: #0000ff">auto</span> logKernel = laplacianOfGaussian(1, 5, 5); <span style="color: #008000">// laplacian of gaussian, similar to matlabs fspecial(&#39;log&#39;, alpha, width, height)</span>
</pre></div>
<h3 id="sobel">Sobel</h3>
<p>Gradient direction for sobel operator can be defined with input argument:</p>

<div class="sourceCode"><pre class="sourceCode d"><code class="sourceCode d"><span class="co">// GradientDirection.DIR_X:</span>
    -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>,
    -<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>,
    -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>

<span class="co">// GradientDirection.DIR_Y:</span>
    -<span class="dv">1</span>, -<span class="dv">2</span>, -<span class="dv">1</span>,
    <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
    <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>

<span class="co">// GradientDirection.DIAG:</span>
    -<span class="dv">2</span>, -<span class="dv">1</span>, <span class="dv">0</span>,
    -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>,
    <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>

<span class="co">// GradientDirection.DIAG_INV:</span>
    <span class="dv">0</span>, -<span class="dv">1</span>, -<span class="dv">2</span>,
    <span class="dv">1</span>, <span class="dv">0</span>, -<span class="dv">1</span>,
    <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span></code></pre></div>
<h4 id="result-1">Result</h4>
<div class="figure">
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/filter/result/sobel.png?raw=true" alt="alt tag" />
</div>
<h3 id="laplacian">Laplacian</h3>
<p>Laplacian kernel function creates negative 3x3 laplacian kernel defined as:</p>
<div class="sourceCode"><pre class="sourceCode d"><code class="sourceCode d">              | a/<span class="dv">4</span>,    (<span class="dv">1</span>-a)/<span class="dv">4</span>,   a/<span class="dv">4</span> |
    <span class="dv">4</span>/(a+<span class="dv">1</span>) * | (<span class="dv">1</span>-a)/<span class="dv">4</span>   -<span class="dv">1</span>   (<span class="dv">1</span>-a)/<span class="dv">4</span> |
              | a/<span class="dv">4</span>,    (<span class="dv">1</span>-a)/<span class="dv">4</span>,   a/<span class="dv">4</span> |</code></pre></div>
<p>… so for the alpha value of 0 (which is the default value), we get:</p>
<div class="sourceCode"><pre class="sourceCode d"><code class="sourceCode d"><span class="dv">0</span>  <span class="dv">1</span>  <span class="dv">0</span>
<span class="dv">1</span> -<span class="dv">4</span>  <span class="dv">1</span>
<span class="dv">0</span>  <span class="dv">1</span>  <span class="dv">0</span></code></pre></div>
<h4 id="result">Result</h4>
<div class="figure">
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/filter/result/laplace.png?raw=true" alt="alt tag" />
</div>
<h3 id="laplacian-of-gaussian">Laplacian Of Gaussian</h3>
<p>LoG operator function creates an kernel by <a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/log.htm">LoG formula</a>, and normalize it so it’s sum is 0.</p>
<h4 id="result-1">Result</h4>
<div class="figure">
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/filter/result/log.png?raw=true" alt="alt tag" />
</div>
<br>
<h3>Canny Edge Detection</h3>
<p>Also, canny filtering algorithm is implemented in <code>dcv.imgproc.filter</code> module. For the input of grayscale Lena image, canny is calculated by following line of code:</p>
<div><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">auto</span> cannyEdges = gray.canny!<span style="color: #2b91af">ubyte</span>(75);
</pre></div>
<p>And the resulting image looks like this:</p>
<div class="figure">
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/filter/result/cannyedges.png?raw=true" alt="alt tag" />
</div>
<br><br><span><big>Complete code:</big></span>
<div ><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">module</span> dcv.example.convolution;
<span style="color: #008000">/** </span>
<span style="color: #008000"> * Spatial image filtering example using dcv library.</span>
<span style="color: #008000"> */</span>

<span style="color: #0000ff">import</span> std.experimental.ndslice;
<span style="color: #0000ff">import</span> std.stdio : writeln;
<span style="color: #0000ff">import</span> std.datetime : StopWatch;
<span style="color: #0000ff">import</span> std.math : fabs;
<span style="color: #0000ff">import</span> std.array : array;
<span style="color: #0000ff">import</span> std.algorithm.iteration : map;

<span style="color: #0000ff">import</span> dcv.core : Image, asType, ranged, ImageFormat;
<span style="color: #0000ff">import</span> dcv.io : imread, imwrite;
<span style="color: #0000ff">import</span> dcv.imgproc;


<span style="color: #2b91af">int</span> main(string[] args) {

    string impath = (args.length &lt; 2) ? <span style="color: #a31515">&quot;../data/lena.png&quot;</span> : args[1];

    Image img = imread(impath); <span style="color: #008000">// read an image from filesystem.</span>

    <span style="color: #0000ff">if</span> (img.empty) { <span style="color: #008000">// check if image is properly read.</span>
        writeln(<span style="color: #a31515">&quot;Cannot read image at: &quot;</span> ~ impath);
        <span style="color: #0000ff">return</span> 1;
    }

    Slice!(3, <span style="color: #2b91af">float</span>*) imslice = img
        .asType!<span style="color: #2b91af">float</span> <span style="color: #008000">// convert Image data type from ubyte to float</span>
            .sliced!<span style="color: #2b91af">float</span>; <span style="color: #008000">// slice image data - calls img.data!float.sliced(img.height, img.width, img.channels)</span>

    <span style="color: #0000ff">auto</span> gray = imslice.rgb2gray; <span style="color: #008000">// convert rgb image to grayscale</span>

    <span style="color: #0000ff">auto</span> gaussianKernel = gaussian!<span style="color: #2b91af">float</span>(2, 5, 5); <span style="color: #008000">// create gaussian convolution kernel (sigma, kernel width and height)</span>
    <span style="color: #0000ff">auto</span> sobelXKernel = sobel!<span style="color: #2b91af">real</span>(GradientDirection.DIR_X); <span style="color: #008000">// sobel operator for horizontal (X) gradients</span>
    <span style="color: #0000ff">auto</span> laplacianKernel = laplacian!<span style="color: #2b91af">double</span>; <span style="color: #008000">// laplacian kernel, similar to matlabs fspecial(&#39;laplacian&#39;, alpha)</span>
    <span style="color: #0000ff">auto</span> logKernel = laplacianOfGaussian(1, 5, 5); <span style="color: #008000">// laplacian of gaussian, similar to matlabs fspecial(&#39;log&#39;, alpha, width, height)</span>

    <span style="color: #008000">// perform convolution for each kernel</span>
    <span style="color: #0000ff">auto</span> blur = imslice.conv(gaussianKernel);
    <span style="color: #0000ff">auto</span> xgrads = gray.conv(sobelXKernel);
    <span style="color: #0000ff">auto</span> laplaceEdges = gray.conv(laplacianKernel);
    <span style="color: #0000ff">auto</span> logEdges = gray.conv(logKernel);

    <span style="color: #008000">// calculate canny edges</span>
    <span style="color: #0000ff">auto</span> cannyEdges = gray.canny!<span style="color: #2b91af">ubyte</span>(75);
    <span style="color: #008000">// scale values from 0 to 255 to preview gradient direction and magnitude</span>
    xgrads = xgrads.byElement.ranged(0, 255).array.sliced(xgrads.shape);

    <span style="color: #008000">// Take absolute values and range them from 0 to 255, to preview edges</span>
    laplaceEdges = laplaceEdges.byElement.map!(a =&gt; fabs(a)).ranged(0, 255).array.sliced(laplaceEdges.shape);
    logEdges = logEdges.byElement.map!(a =&gt; fabs(a)).ranged(0, 255).array.sliced(logEdges.shape);

    <span style="color: #008000">// write resulting images on the filesystem.</span>
    blur.asType!<span style="color: #2b91af">ubyte</span>.imwrite(ImageFormat.IF_RGB, <span style="color: #a31515">&quot;./result/outblur.png&quot;</span>);
    xgrads.asType!<span style="color: #2b91af">ubyte</span>.imwrite(ImageFormat.IF_MONO, <span style="color: #a31515">&quot;./result/sobel.png&quot;</span>);
    laplaceEdges.asType!<span style="color: #2b91af">ubyte</span>.imwrite(ImageFormat.IF_MONO, <span style="color: #a31515">&quot;./result/laplace.png&quot;</span>);
    logEdges.asType!<span style="color: #2b91af">ubyte</span>.imwrite(ImageFormat.IF_MONO, <span style="color: #a31515">&quot;./result/log.png&quot;</span>);
    cannyEdges.imwrite(ImageFormat.IF_MONO, <span style="color: #a31515">&quot;./result/cannyedges.png&quot;</span>);

    <span style="color: #0000ff">return</span> 0;
}
</pre></div>
